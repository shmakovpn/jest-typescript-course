# Jest typescript course

Тестирование `typescript` кода с использование `jest`.
Testing `typescript` code using `jest`.

```
Доверяй и не перепроверяй.
```

Для чего все это надо? Я же задам вопрос по другому, как стать ценным специалистом, особенно если вы новичок.
Если вы новичок, вам не доверяют.

_Хотя вопрос куда глубже, не стоит заниматься шапкозакидательством, излишне доверяя даже самому себе, вне зависимости от того новичок вы или специалист с десятилетним опытом_.

И так. Вам ненадежен. Значит за вами надо перепроверять. Перепроверять - тратить время старших коллег.

Даже если вы работаете за 0 рублей, фирма все равно несет большие издержки.
Поэтому, без опыта вас не возьмут даже _за еду_, так как попутно потребуется кормить еще и middle-а
или даже senior-а, чьи аппетиты дорого обходятся любой компании.

Если вы пишите тесты, и делаете это на хотя бы минимально достойном уровне, ваш код работает и это можно доказать.
Таким образом, за счет автоматизации бизнес процесса код-ревью, можно существенно сэкономить время старших коллег.

Ура! В списке из 10ков тысяч Junior-ов:

- имеющих примерно одинаковые запросы по зарплате,
- обладающих начальными, но уже вполне достаточными знаниями основ языка для написания хоть как-то работающего кода.

Среди бесценных специалистов, т.е. людей пока еще не представляющих какой-либо ценности.
Вы человек которому можно доверять. Поверьте senior-ы, которые будут вас собеседовать, тоже люди, им есть чем заняться помимо вас, и они не хотят страдать.

## Create project structure

Создание структуры приложения.

Первым делом создадим папку проекта. В ней будет происходить вся работа.

```shell
mkdir jest-typescript-course  # создаем папку
cd jest-typescript-course  # переходим в нее
code .  # открываем созданную папку в среде разработки VSCode
git init  # делаем папку проекта git-репозиторием
touch README.md  # создаем файл с описанием нашего проекта
touch .gitignore  # создаем конфигурационный файл исключений git-а, оставим пока его пустым.
npm init -y  # делаем папку проекта пустым nodejs пакетом
mkdir docs  # создадим папку с документацией
mkdir src  # создаем папку для файлов с исходным кодом
```

## Hello World

```shell
touch src/index.js  # создаем отправную точку. минимальное работающее приложение "Привет Мир"
code src/index.js  # открываем index.js в VSCode
```

Давайте хоть что-то, что работает, код на языке `javascript` для начала.

```js
/**
 * src/index.js
 */
console.log('Hello World');
```

Запустим код в терминале.

```shell
node src/index.js
```

Результат:
![hello world from js](docs/images/hello-world-js.png)

Если удалось получить строку `Hello World` в терминале, значит мы на правильном пути.
Идем дальше. Превратим наш код из `javascript` в `typescript` и заставим его работать.

Переименуем файл `src/index.js` в `src/index.ts`.

```shell
mv src/index.js src/index.ts  # меняем расширение файла на *.ts
code src/index.ts  # открываем полученный файл в VSCode
```

Внесем изменения в файл.

```typescript
interface Hello {
  from: string;
  to: string;
}
const helloWorld: Hello = {
  from: 'typescript',
  to: 'World',
};
console.log(`Hello ${helloWorld.to} from ${helloWorld.from}`);
```

Запустить `typescript`-код просто так уже не получиться.

![run-typescript-code-failed](docs/images/run-typescript-code-failed.png)

Давайте установим компилятор `typescript`. Но сперва сделаем коммит в систему контроля версий `git`.

```shell
git status  # текущее состояние системы контроля версий git
```

![git-status-1](docs/images/git-status-1.png)

`On branch master` - мы находимся на ветке с именем master.
`No commits yet` - у нас нет ни одного commit-а.
`Untracked files` - у нас имеются не контролируемые git-ом файлы и папки. Их имена выделены красным.
`nothing add to commit but untracked files present` - Нечего commit-ить, но есть не отслеживаемые файлы.

```shell
git add .  # добавим в снимок git текущий каталог (точка означает текущую папку)
git status  # открою маленький секрет, чем чаще вводишь git status, тем быстрее изучаешь git
```

![git-status-2](docs/images/git-status-2.png)

Мы по прежнему находимся на ветке master. `On branch master` и у нас нет commit-ов `No commits yet`.
Однако, есть изменения готовые для сохранения в commit `Changes to be committed`.
Файлы помеченные зеленым войдут в будущий коммит. Который мы обязательно сделаем очень скоро.

Не стоит переживать насчет откуда то взявшихся файлов в папке docs/images
![git-status-docs-files](docs/images/git-status-docs-files.png)
Просто, я пишу эту книгу в том же git репозитории, и git видит, как я добавляю скриншоты.
Не обращайте внимание.

Давай создадим наш первый commit. Посмотрим текущее состояние репозитория, а также историю commit-ов.

```shell
git commit -m 'first commit'
git status  # текущее состояние репозитория git
git log  # история commit-ов
```

![git-commit-1](docs/images/git-commit-1.png)

Отлично. Мы создали новый `npm` пакет (`javascript` библиотеку),  попробовали что-то запускать и зафиксировали полученный результат в виде commit-а в git-репозитории.

## Установка `typescript`

Честно. Не хотел писать про столь тривиальную вещь как установка `typescript`-компилятора.
Но давайте его установим, посмотрим, что изменилось, и причем тут git.

```shell
npm install -D typescript  # менеджер javascript-пакетов (npm) установи(install) пакет для разработки (-D) с именем typescript
```

![npm-install-typescript](docs/images/npm-install-typescript.png)

`added 1 package, and ..` - добавлен новый `javascript`-пакет.

```shell
git status
```

![git-status-3](docs/images/git-status-3.png)
Теперь у нас есть:
 - `Changes not staged for commit` - измененные файлы, которые не добавлены в будущий commit
 - `Untracked files` - не отслеживаемые git-ом файлы и папки.

Где:
 - `node_modules/` - каталог с установленными сторонними `javascript`-пакетами (мы только что установили компилятор `typescript`)
 - `package.json` - конфигурационный файл нашего `javascript` пакета. О нем поговорим, чуть позже.
 - `package-lock.json` - файл с информацией об установленных пакетах.

У каждого пользователя нашей программы `package-lock.json` будет свой, он будет создавать и обновляться автоматически,
при установке или обновлении нашей программы. Распространять нашу версию данного файла не имеет никакого смысла.

Также, у каждого пользователя будет свой каталог `node_modules`. Как и файл `package-lock.json`, 
он будет сформирован автоматически в зависимости от версии операционной системы пользователя, 
версии `nodejs` - интерпретатора `javascript`, установленной на компьютере пользователя и т.д.
Это чужой код, как правило он занимает много места, до сотен мегабайт, распространять его только мешать и вводить компьютер пользователя в заблуждение.

К счастью, у нас есть возможность подсказать системе контроля версий, чтобы она исключила из репозитория не нужные объекты. 
Внесем изменения в файл `.gitignore`.

```
# .gitignore

# чужой код
node_modules/

# файлы создаваемые автоматически
package-lock.json
```

```shell
git status
```

![git-status-4](docs/images/git-status-4.png)

Ура! Мы исключили из git-а те файлы, которые мы не собирается распространять.

```shell
git diff package.json
```

![git-diff-1](docs/images/git-diff-1.png)

Вспоминайте, что мы делали две минуты назад. Правильно. Мы установили `typescript` с ключом `-D`.
Менеджер пакетов `npm` заботливо сохранил соответствующую запись в словарик `devDependencies` (зависимости для разработки).

Пора зафиксировать изменения.

```shell
git add .
git commit -m 'установлен typescript'
git status
git log -n 1  # выведем последнюю запись в истории commit-ов
```

![git-status-5](docs/images/git-status-5.png)

Теперь пришло время проверить, что `typescript` установлен.

```shell
./node_modules/.bin/tsc --version
```

![tsc-version](docs/images/tsc-version.png)

На листинге выше, мы запрашиваем версию установленного компилятора. Запрос версии программы, это довольно частый прием,
чтобы проверить, что программа установлена и способна работать. Он ничего не сломает и, как правило, работает сразу,
из коробки, не требуя конфигурационных файлов и прочих настроек.

Одна строка, а как в ней много сказано. Особенно для новичка. Разберем все более детально:
 - `./node_modules/.bin/` - путь к каталогу с исполняемыми файлами, которые притащил нам пакетный менеджер `npm`,
 - `tsc` - компилятор `typescript`,
 - `--version` - просим `tsc` вывести его текущую версию и завершится.

Предлагаю отвлечься на минутку и порассуждать на тем, зачем такой длинный путь `./node_modules/.bin/tsc`?
Почему нельзя просто `tsc`? Давайте проверим.

```shell
tsc
```

![tsc-not-found](docs/images/tsc-not-found.png)

`Command 'tsc' not found` - команда 'tsc' не найдена. Так произошло, потому, что мы установили компилятор `typescript`
по факту в `node_modules`, а не там где операционная система ищет запускаемые файлы (`$PATH`).

```shell
echo $PATH  
# echo - вывести на экран, 
# $PATH - переменная окружения, список путей, где искать исполняемые файлы,
# разделенных через двоеточие
```

![echo-path](docs/images/echo_path.png)

Как видим пути к `./node_modules/.bin` в `$PATH` нет. Его можно добавить.

```shell
export PATH="./node_modules/.bin:$PATH"
echo $PATH
```

![echo-path2](docs/images/echo_path2.png)

```shell
tsc --version
```

![tsc-version2](docs/images/tsc-version2.png)

"Это, что теперь каждый раз `$PATH` менять?" - спросите вы.
Выход есть, точнее выходы:
 - установить `typescript` глобально,
 - автоматизировать изменение `$PATH`.

Но сперва, давайте вернем `$PATH` как было. 

```shell
export PATH=$(echo $PATH | sed -re 's/\.\/node_modules\/\.bin:?//')
# sed - stream editor, потоковый редактор текста
# -re - использовать "регулярные выражения"
# s/\.\/node_modules\/\.bin:?// регулярное выражение замены. s/шаблон поиска - что менять/на что менять/
# служебные символы (точки, слэши и т.д.) должны быть экранированы, поэтому '.' становится '\.', 
# а '/' -> '\/'
# ':?' означает включить символ ':' в шаблон поиска, как опциональный.
# Если в строке находится подстрока соответствующая шаблону, она заменяется, в нашем случае на пустую строку,
# т.е. удаляется
echo $PATH
```

![echo-path3](docs/images/echo-path3.png)



## tsconfig

Компилятор `typescript` штука сложная и требует настроек, которые он будет брать из файла `tsconfig.json`.
